import{r as ee,j as Q}from"./index-CNygDEi8.js";import{b5 as C,K as re,ak as oe,ah as se,ai as ie,b6 as ae,b7 as te,b8 as le,V as E,a0 as ne,A as ue,D as ce,Q as fe,b9 as me,ad as de,u as j,E as he,j as pe,M as ge,ba as be,bb as Ae,c as we,L as xe}from"./OrbitControls-T7DR67G2.js";import{W as Te}from"./three.utils-DT_mVYKh.js";function ye(e,i,o=!0){if(!i||!i.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function l(t){if(t.normalized||t.isInterleavedBufferAttribute){const a=new Float32Array(t.count*t.itemSize);for(let c=0,h=0;c<t.count;c++)a[h++]=t.getX(c),a[h++]=t.getY(c),t.itemSize>2&&(a[h++]=t.getZ(c));return a}return t.array instanceof Float32Array?t.array:new Float32Array(t.array)}const r=e.index?e.toNonIndexed():e,u=i.generateTangents(l(r.attributes.position),l(r.attributes.normal),l(r.attributes.uv));if(o)for(let t=3;t<u.length;t+=4)u[t]*=-1;return r.setAttribute("tangent",new C(u,4)),e!==r&&e.copy(r),e}function Be(e,i=!1){const o=e[0].index!==null,l=new Set(Object.keys(e[0].attributes)),r=new Set(Object.keys(e[0].morphAttributes)),u={},t={},a=e[0].morphTargetsRelative,c=new re;let h=0;for(let n=0;n<e.length;++n){const s=e[n];let p=0;if(o!==(s.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const f in s.attributes){if(!l.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+'. All geometries must have compatible attributes; make sure "'+f+'" attribute exists among all geometries, or in none of them.'),null;u[f]===void 0&&(u[f]=[]),u[f].push(s.attributes[f]),p++}if(p!==l.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+". Make sure all geometries have the same number of attributes."),null;if(a!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const f in s.morphAttributes){if(!r.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+".  .morphAttributes must be consistent throughout all geometries."),null;t[f]===void 0&&(t[f]=[]),t[f].push(s.morphAttributes[f])}if(i){let f;if(o)f=s.index.count;else if(s.attributes.position!==void 0)f=s.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+n+". The geometry must have either an index or a position attribute"),null;c.addGroup(h,f,n),h+=f}}if(o){let n=0;const s=[];for(let p=0;p<e.length;++p){const f=e[p].index;for(let d=0;d<f.count;++d)s.push(f.getX(d)+n);n+=e[p].attributes.position.count}c.setIndex(s)}for(const n in u){const s=J(u[n]);if(!s)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+n+" attribute."),null;c.setAttribute(n,s)}for(const n in t){const s=t[n][0].length;if(s===0)break;c.morphAttributes=c.morphAttributes||{},c.morphAttributes[n]=[];for(let p=0;p<s;++p){const f=[];for(let m=0;m<t[n].length;++m)f.push(t[n][m][p]);const d=J(f);if(!d)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+n+" morphAttribute."),null;c.morphAttributes[n].push(d)}}return c}function J(e){let i,o,l,r=-1,u=0;for(let h=0;h<e.length;++h){const n=e[h];if(i===void 0&&(i=n.array.constructor),i!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(o===void 0&&(o=n.itemSize),o!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(l===void 0&&(l=n.normalized),l!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(r===-1&&(r=n.gpuType),r!==n.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;u+=n.count*o}const t=new i(u),a=new C(t,o,l);let c=0;for(let h=0;h<e.length;++h){const n=e[h];if(n.isInterleavedBufferAttribute){const s=c/o;for(let p=0,f=n.count;p<f;p++)for(let d=0;d<o;d++){const m=n.getComponent(p,d);a.setComponent(p+s,d,m)}}else t.set(n.array,c);c+=n.count*o}return r!==void 0&&(a.gpuType=r),a}function ve(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?$(e):e.isInstancedBufferAttribute?new oe().copy(e):new C().copy(e)}function ze(e){let i,o=0,l=0;for(let h=0,n=e.length;h<n;++h){const s=e[h];if(i===void 0&&(i=s.array.constructor),i!==s.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;o+=s.array.length,l+=s.itemSize}const r=new se(new i(o),l);let u=0;const t=[],a=["getX","getY","getZ","getW"],c=["setX","setY","setZ","setW"];for(let h=0,n=e.length;h<n;h++){const s=e[h],p=s.itemSize,f=s.count,d=new ie(r,p,u,s.normalized);t.push(d),u+=p;for(let m=0;m<f;m++)for(let v=0;v<p;v++)d[c[v]](m,s[a[v]](m))}return t}function $(e){const i=e.data.array.constructor,o=e.count,l=e.itemSize,r=e.normalized,u=new i(o*l);let t;e.isInstancedInterleavedBufferAttribute?t=new oe(u,l,r,e.meshPerAttribute):t=new C(u,l,r);for(let a=0;a<o;a++)t.setX(a,e.getX(a)),l>=2&&t.setY(a,e.getY(a)),l>=3&&t.setZ(a,e.getZ(a)),l>=4&&t.setW(a,e.getW(a));return t}function Ee(e){const i=e.attributes,o=e.morphTargets,l=new Map;for(const r in i){const u=i[r];u.isInterleavedBufferAttribute&&(l.has(u)||l.set(u,$(u)),i[r]=l.get(u))}for(const r in o){const u=o[r];u.isInterleavedBufferAttribute&&(l.has(u)||l.set(u,$(u)),o[r]=l.get(u))}}function Se(e){let i=0;for(const l in e.attributes){const r=e.getAttribute(l);i+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}const o=e.getIndex();return i+=o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0,i}function Ie(e,i=1e-4){i=Math.max(i,Number.EPSILON);const o={},l=e.getIndex(),r=e.getAttribute("position"),u=l?l.count:r.count;let t=0;const a=Object.keys(e.attributes),c={},h={},n=[],s=["getX","getY","getZ","getW"],p=["setX","setY","setZ","setW"];for(let w=0,T=a.length;w<T;w++){const x=a[w],g=e.attributes[x];c[x]=new C(new g.array.constructor(g.count*g.itemSize),g.itemSize,g.normalized);const y=e.morphAttributes[x];y&&(h[x]=new C(new y.array.constructor(y.count*y.itemSize),y.itemSize,y.normalized))}const f=i*.5,d=Math.log10(1/i),m=Math.pow(10,d),v=f*m;for(let w=0;w<u;w++){const T=l?l.getX(w):w;let x="";for(let g=0,y=a.length;g<y;g++){const B=a[g],A=e.getAttribute(B),z=A.itemSize;for(let S=0;S<z;S++)x+=`${~~(A[s[S]](T)*m+v)},`}if(x in o)n.push(o[x]);else{for(let g=0,y=a.length;g<y;g++){const B=a[g],A=e.getAttribute(B),z=e.morphAttributes[B],S=A.itemSize,U=c[B],G=h[B];for(let I=0;I<S;I++){const M=s[I],k=p[I];if(U[k](t,A[M](T)),z)for(let X=0,W=z.length;X<W;X++)G[X][k](t,z[X][M](T))}}o[x]=t,n.push(t),t++}}const b=e.clone();for(const w in e.attributes){const T=c[w];if(b.setAttribute(w,new C(T.array.slice(0,t*T.itemSize),T.itemSize,T.normalized)),w in h)for(let x=0;x<h[w].length;x++){const g=h[w][x];b.morphAttributes[w][x]=new C(g.array.slice(0,t*g.itemSize),g.itemSize,g.normalized)}}return b.setIndex(n),b}function Me(e,i){if(i===ae)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(i===te||i===le){let o=e.getIndex();if(o===null){const t=[],a=e.getAttribute("position");if(a!==void 0){for(let c=0;c<a.count;c++)t.push(c);e.setIndex(t),o=e.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e}const l=o.count-2,r=[];if(i===te)for(let t=1;t<=l;t++)r.push(o.getX(0)),r.push(o.getX(t)),r.push(o.getX(t+1));else for(let t=0;t<l;t++)t%2===0?(r.push(o.getX(t)),r.push(o.getX(t+1)),r.push(o.getX(t+2))):(r.push(o.getX(t+2)),r.push(o.getX(t+1)),r.push(o.getX(t)));r.length/3!==l&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const u=e.clone();return u.setIndex(r),u.clearGroups(),u}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",i),e}function Ge(e){const i=new E,o=new E,l=new E,r=new E,u=new E,t=new E,a=new E,c=new E,h=new E;function n(P,L,V,q,H,_,D,R){i.fromBufferAttribute(L,H),o.fromBufferAttribute(L,_),l.fromBufferAttribute(L,D);const O=P.morphTargetInfluences;if(V&&O){a.set(0,0,0),c.set(0,0,0),h.set(0,0,0);for(let Y=0,K=V.length;Y<K;Y++){const F=O[Y],Z=V[Y];F!==0&&(r.fromBufferAttribute(Z,H),u.fromBufferAttribute(Z,_),t.fromBufferAttribute(Z,D),q?(a.addScaledVector(r,F),c.addScaledVector(u,F),h.addScaledVector(t,F)):(a.addScaledVector(r.sub(i),F),c.addScaledVector(u.sub(o),F),h.addScaledVector(t.sub(l),F)))}i.add(a),o.add(c),l.add(h)}P.isSkinnedMesh&&(P.applyBoneTransform(H,i),P.applyBoneTransform(_,o),P.applyBoneTransform(D,l)),R[H*3+0]=i.x,R[H*3+1]=i.y,R[H*3+2]=i.z,R[_*3+0]=o.x,R[_*3+1]=o.y,R[_*3+2]=o.z,R[D*3+0]=l.x,R[D*3+1]=l.y,R[D*3+2]=l.z}const s=e.geometry,p=e.material;let f,d,m;const v=s.index,b=s.attributes.position,w=s.morphAttributes.position,T=s.morphTargetsRelative,x=s.attributes.normal,g=s.morphAttributes.position,y=s.groups,B=s.drawRange;let A,z,S,U,G,I,M;const k=new Float32Array(b.count*b.itemSize),X=new Float32Array(x.count*x.itemSize);if(v!==null)if(Array.isArray(p))for(A=0,S=y.length;A<S;A++)for(G=y[A],I=Math.max(G.start,B.start),M=Math.min(G.start+G.count,B.start+B.count),z=I,U=M;z<U;z+=3)f=v.getX(z),d=v.getX(z+1),m=v.getX(z+2),n(e,b,w,T,f,d,m,k),n(e,x,g,T,f,d,m,X);else for(I=Math.max(0,B.start),M=Math.min(v.count,B.start+B.count),A=I,S=M;A<S;A+=3)f=v.getX(A),d=v.getX(A+1),m=v.getX(A+2),n(e,b,w,T,f,d,m,k),n(e,x,g,T,f,d,m,X);else if(Array.isArray(p))for(A=0,S=y.length;A<S;A++)for(G=y[A],I=Math.max(G.start,B.start),M=Math.min(G.start+G.count,B.start+B.count),z=I,U=M;z<U;z+=3)f=z,d=z+1,m=z+2,n(e,b,w,T,f,d,m,k),n(e,x,g,T,f,d,m,X);else for(I=Math.max(0,B.start),M=Math.min(b.count,B.start+B.count),A=I,S=M;A<S;A+=3)f=A,d=A+1,m=A+2,n(e,b,w,T,f,d,m,k),n(e,x,g,T,f,d,m,X);const W=new ne(k,3),N=new ne(X,3);return{positionAttribute:b,normalAttribute:x,morphedPositionAttribute:W,morphedNormalAttribute:N}}function Re(e){if(e.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let i=e.groups;if(i=i.sort((t,a)=>t.materialIndex!==a.materialIndex?t.materialIndex-a.materialIndex:t.start-a.start),e.getIndex()===null){const t=e.getAttribute("position"),a=[];for(let c=0;c<t.count;c+=3)a.push(c,c+1,c+2);e.setIndex(a)}const o=e.getIndex(),l=[];for(let t=0;t<i.length;t++){const a=i[t],c=a.start,h=c+a.count;for(let n=c;n<h;n++)l.push(o.getX(n))}e.dispose(),e.setIndex(l);let r=0;for(let t=0;t<i.length;t++){const a=i[t];a.start=r,r+=a.count}let u=i[0];e.groups=[u];for(let t=1;t<i.length;t++){const a=i[t];u.materialIndex===a.materialIndex?u.count+=a.count:(u=a,e.groups.push(u))}return e}function Ue(e,i=Math.PI/3){const o=Math.cos(i),l=(1+1e-10)*100,r=[new E,new E,new E],u=new E,t=new E,a=new E,c=new E;function h(m){const v=~~(m.x*l),b=~~(m.y*l),w=~~(m.z*l);return`${v},${b},${w}`}const n=e.index?e.toNonIndexed():e,s=n.attributes.position,p={};for(let m=0,v=s.count/3;m<v;m++){const b=3*m,w=r[0].fromBufferAttribute(s,b+0),T=r[1].fromBufferAttribute(s,b+1),x=r[2].fromBufferAttribute(s,b+2);u.subVectors(x,T),t.subVectors(w,T);const g=new E().crossVectors(u,t).normalize();for(let y=0;y<3;y++){const B=r[y],A=h(B);A in p||(p[A]=[]),p[A].push(g)}}const f=new Float32Array(s.count*3),d=new C(f,3,!1);for(let m=0,v=s.count/3;m<v;m++){const b=3*m,w=r[0].fromBufferAttribute(s,b+0),T=r[1].fromBufferAttribute(s,b+1),x=r[2].fromBufferAttribute(s,b+2);u.subVectors(x,T),t.subVectors(w,T),a.crossVectors(u,t).normalize();for(let g=0;g<3;g++){const y=r[g],B=h(y),A=p[B];c.set(0,0,0);for(let z=0,S=A.length;z<S;z++){const U=A[z];a.dot(U)>o&&c.add(U)}c.normalize(),d.setXYZ(b+g,c.x,c.y,c.z)}}return n.setAttribute("normal",d),n}const Xe=Object.freeze(Object.defineProperty({__proto__:null,computeMikkTSpaceTangents:ye,computeMorphedAttributes:Ge,deepCloneAttribute:ve,deinterleaveAttribute:$,deinterleaveGeometry:Ee,estimateBytesUsed:Se,interleaveAttributes:ze,mergeAttributes:J,mergeGeometries:Be,mergeGroups:Re,mergeVertices:Ie,toCreasedNormals:Ue,toTrianglesDrawMode:Me},Symbol.toStringTag,{value:"Module"}));console.log("BufferGeometryUtils :",Xe);function He(){const e=ee.useRef(null);return ee.useEffect(()=>{const i=e.current;if(i){let o=function(N,P,L,V,q,H){let _=L-N,D=V-P,R=q-L,O=H-V,Y=Math.sqrt(_*_+D*D),K=Math.sqrt(R*R+O*O),Z=(_*R+D*O)/(Y*K);return Math.acos(Z)*(180/Math.PI)},l=function(N,P,L){let V=L.clone().sub(P);new j(-V.y,V.x);let H=N.clone().sub(P).dot(V)/V.lengthSq();return P.clone().addScaledVector(V,H)};const r=new Te(i);r.init(),r.update(),r.updateSize(),r.addOrbitControls();const{scene:u,camera:t,renderer:a}=r;t.position.set(0,0,35);const c=new ue(4210752,10);r.createModel(c),t.lookAt(0,0,0);const h=new ce(16777215,.5);u.add(h);let n=1,s=10;const p=new fe;let f=n/2,d=s/2;const m=1,v=10;let b=[-f,-d];b[0]+=-v;let w=[-f,d],T=[s,d],x=[s,-d];p.moveTo(...b),p.lineTo(...w),p.lineTo(...T),p.lineTo(...x),p.lineTo(...b);const g=new me;de.degToRad(o(...x,...b,...w));let y=l(new j(...b),new j(...x),new j(...w));console.log(y),y.distanceTo(new j(...w)),y.distanceTo(new j(...b)),f-=m,d-=m,s-=m,b=[-f,-d],b[0]+=-(v-m),w=[-f,d],T=[s,d],x=[s,-d],g.moveTo(...b),g.lineTo(...w),g.lineTo(...T),g.lineTo(...x),g.lineTo(...b),p.holes.push(g),n=20,s=20;const B={steps:40,depth:10,bevelEnabled:!1,bevelThickness:10,bevelSize:10,bevelOffset:10,bevelSegments:10},A=new he([p],B),z=new pe({color:65280,wireframe:!1}),S=new ge(A,z);u.add(S);let U=new be,G=p.getPoints(),I,M;for(let N=0;N<G.length;N++)I=G[N],M=G[N+1]||I,U.add(new Ae(new E(I.x,I.y,0),new E(M.x,M.y,0)));let k=new re().setFromPoints(U.getPoints()),X=new we({color:255}),W=new xe(k,X);u.add(W)}},[]),Q.jsx(Q.Fragment,{children:Q.jsx("canvas",{style:{display:"block",width:"100vw",height:"100vh"},ref:e})})}export{He as default};
